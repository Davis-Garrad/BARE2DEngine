<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BARE2D: Other_Libraries/PicoPNG.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="BARE.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BARE2D
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_pico_p_n_g_8cpp_source.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">PicoPNG.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="_pico_p_n_g_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#</span><span class="preprocessor">include</span> <span class="preprocessor">&lt;</span><span class="preprocessor">vector</span><span class="preprocessor">&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="keyword">using</span> <span class="keyword">namespace</span> std;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="keyword">namespace</span> <a class="code" href="namespace_b_a_r_e2_d.html">BARE2D</a> {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160; </div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    <span class="comment">/*</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">    decodePNG: The picoPNG function, decodes a PNG file buffer in memory, into a raw pixel buffer.</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">    out_image: output parameter, this will contain the raw pixels after decoding.</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">    By default the output is 32-bit RGBA color.</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">    The std::vector is automatically resized to the correct size.</span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">    image_width: output_parameter, this will contain the width of the image in pixels.</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">    image_height: output_parameter, this will contain the height of the image in pixels.</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment">    in_png: pointer to the buffer of the PNG file in memory. To get it from a file on</span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">    disk, load it and store it in a memory buffer yourself first.</span></div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment">    in_size: size of the input PNG file in bytes.</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment">    convert_to_rgba32: optional parameter, true by default.</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment">    Set to true to get the output in RGBA 32-bit (8 bit per channel) color format</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment">    no matter what color type the original PNG image had. This gives predictable,</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment">    useable data from any random input PNG.</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment">    Set to false to do no color conversion at all. The result then has the same data</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment">    type as the PNG image, which can range from 1 bit to 64 bits per pixel.</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment">    Information about the color type or palette colors are not provided. You need</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment">    to know this information yourself to be able to use the data so this only</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment">    works for trusted PNG files. Use LodePNG instead of picoPNG if you need this information.</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment">    return: 0 if success, not 0 if some error occured.</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment">    */</span></div>
<div class="line"><a name="l00028"></a><span class="lineno"><a class="line" href="namespace_b_a_r_e2_d.html#a480b5f334854e31c2d7e026933129480">   28</a></span>&#160;    <span class="keywordtype">int</span> <a class="code" href="namespace_b_a_r_e2_d.html#a480b5f334854e31c2d7e026933129480">decodePNG</a>(std::vector&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;&amp; out_image, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>&amp; image_width, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>&amp; image_height, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in_png, std::size_t in_size, <span class="keywordtype">bool</span> convert_to_rgba32)</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    {</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;        <span class="comment">// picoPNG version 20101224</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;        <span class="comment">// Copyright (c) 2005-2010 Lode Vandevenne</span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;        <span class="comment">//</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;        <span class="comment">// This software is provided &#39;as-is&#39;, without any express or implied</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        <span class="comment">// warranty. In no event will the authors be held liable for any damages</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        <span class="comment">// arising from the use of this software.</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        <span class="comment">//</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        <span class="comment">// Permission is granted to anyone to use this software for any purpose,</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        <span class="comment">// including commercial applications, and to alter it and redistribute it</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        <span class="comment">// freely, subject to the following restrictions:</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;        <span class="comment">//</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;        <span class="comment">//     1. The origin of this software must not be misrepresented; you must not</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;        <span class="comment">//     claim that you wrote the original software. If you use this software</span></div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;        <span class="comment">//     in a product, an acknowledgment in the product documentation would be</span></div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        <span class="comment">//     appreciated but is not required.</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;        <span class="comment">//     2. Altered source versions must be plainly marked as such, and must not be</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        <span class="comment">//     misrepresented as being the original software.</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        <span class="comment">//     3. This notice may not be removed or altered from any source distribution.</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160; </div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        <span class="comment">// picoPNG is a PNG decoder in one C++ function of around 500 lines. Use picoPNG for</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        <span class="comment">// programs that need only 1 .cpp file. Since it&#39;s a single function, it&#39;s very limited,</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        <span class="comment">// it can convert a PNG to raw pixel data either converted to 32-bit RGBA color or</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        <span class="comment">// with no color conversion at all. For anything more complex, another tiny library</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        <span class="comment">// is available: LodePNG (lodepng.c(pp)), which is a single source and header file.</span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        <span class="comment">// Apologies for the compact code style, it&#39;s to make this tiny.</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160; </div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> LENBASE[29] = { 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258 };</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> LENEXTRA[29] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0 };</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> DISTBASE[30] = { 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 };</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> DISTEXTRA[30] = { 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 };</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> CLCL[19] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 }; <span class="comment">//code length code lengths</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        <span class="keyword">struct</span> Zlib <span class="comment">//nested functions for zlib decompression</span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        {</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;            <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> readBitFromStream(size_t&amp; bitp, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* bits) { <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> result = (bits[bitp &gt;&gt; 3] &gt;&gt; (bitp &amp; 0x7)) &amp; 1; bitp++; <span class="keywordflow">return</span> result; }</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;            <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> readBitsFromStream(size_t&amp; bitp, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* bits, size_t nbits)</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;            {</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;                <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> result = 0;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;                <span class="keywordflow">for</span> (size_t i = 0; i &lt; nbits; i++) result += (readBitFromStream(bitp, bits)) &lt;&lt; i;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;            }</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;            <span class="keyword">struct</span> HuffmanTree</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;            {</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                <span class="keywordtype">int</span> makeFromLengths(<span class="keyword">const</span> std::vector&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>&gt;&amp; bitlen, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> maxbitlen)</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;                { <span class="comment">//make tree given the lengths</span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;                    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> numcodes = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(bitlen.size()), treepos = 0, nodefilled = 0;</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;                    std::vector&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>&gt; tree1d(numcodes), blcount(maxbitlen + 1, 0), nextcode(maxbitlen + 1, 0);</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bits = 0; bits &lt; numcodes; bits++) blcount[bitlen[bits]]++; <span class="comment">//count number of instances of each code length</span></div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bits = 1; bits &lt;= maxbitlen; bits++) nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) &lt;&lt; 1;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> n = 0; n &lt; numcodes; n++) <span class="keywordflow">if</span> (bitlen[n] != 0) tree1d[n] = nextcode[bitlen[n]]++; <span class="comment">//generate all the codes</span></div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;                    tree2d.clear(); tree2d.resize(numcodes * 2, 32767); <span class="comment">//32767 here means the tree2d isn&#39;t filled there yet</span></div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> n = 0; n &lt; numcodes; n++) <span class="comment">//the codes</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i = 0; i &lt; bitlen[n]; i++) <span class="comment">//the bits for this code</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;                    {</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;                        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bit = (tree1d[n] &gt;&gt; (bitlen[n] - i - 1)) &amp; 1;</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;                        <span class="keywordflow">if</span> (treepos &gt; numcodes - 2) <span class="keywordflow">return</span> 55;</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;                        <span class="keywordflow">if</span> (tree2d[2 * treepos + bit] == 32767) <span class="comment">//not yet filled in</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;                        {</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                            <span class="keywordflow">if</span> (i + 1 == bitlen[n]) { tree2d[2 * treepos + bit] = n; treepos = 0; } <span class="comment">//last bit</span></div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;                            <span class="keywordflow">else</span> { tree2d[2 * treepos + bit] = ++nodefilled + numcodes; treepos = nodefilled; } <span class="comment">//addresses are encoded as values &gt; numcodes</span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;                        } <span class="keywordflow">else</span> treepos = tree2d[2 * treepos + bit] - numcodes; <span class="comment">//subtract numcodes from address to get address value</span></div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;                    }</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;                    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;                }</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;                <span class="keywordtype">int</span> decode(<span class="keywordtype">bool</span>&amp; decoded, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>&amp; result, size_t&amp; treepos, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bit) <span class="keyword">const</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;                { <span class="comment">//Decodes a symbol from the tree</span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;                    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> numcodes = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)tree2d.size() / 2;</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;                    <span class="keywordflow">if</span> (treepos &gt;= numcodes) <span class="keywordflow">return</span> 11; <span class="comment">//error: you appeared outside the codetree</span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;                    result = tree2d[2 * treepos + bit];</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;                    decoded = (result &lt; numcodes);</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;                    treepos = decoded ? 0 : result - numcodes;</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;                    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;                }</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;                std::vector&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>&gt; tree2d; <span class="comment">//2D representation of a huffman tree: The one dimension is &quot;0&quot; or &quot;1&quot;, the other contains all nodes and leaves of the tree.</span></div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;            };</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;            <span class="keyword">struct</span> Inflator</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;            {</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;                <span class="keywordtype">int</span> error;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;                <span class="keywordtype">void</span> inflate(std::vector&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;&amp; out, <span class="keyword">const</span> std::vector&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;&amp; in, size_t inpos = 0)</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;                {</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;                    size_t bp = 0, pos = 0; <span class="comment">//bit pointer and byte pointer</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;                    error = 0;</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;                    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> BFINAL = 0;</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;                    <span class="keywordflow">while</span> (!BFINAL &amp;&amp; !error)</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                    {</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;                        <span class="keywordflow">if</span> (bp &gt;&gt; 3 &gt;= in.size()) { error = 52; <span class="keywordflow">return</span>; } <span class="comment">//error, bit pointer will jump past memory</span></div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;                        BFINAL = readBitFromStream(bp, &amp;in[inpos]);</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;                        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> BTYPE = readBitFromStream(bp, &amp;in[inpos]); BTYPE += 2 * readBitFromStream(bp, &amp;in[inpos]);</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;                        <span class="keywordflow">if</span> (BTYPE == 3) { error = 20; <span class="keywordflow">return</span>; } <span class="comment">//error: invalid BTYPE</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;                        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (BTYPE == 0) inflateNoCompression(out, &amp;in[inpos], bp, pos, in.size());</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;                        <span class="keywordflow">else</span> inflateHuffmanBlock(out, &amp;in[inpos], bp, pos, in.size(), BTYPE);</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;                    }</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;                    <span class="keywordflow">if</span> (!error) out.resize(pos); <span class="comment">//Only now we know the true size of out, resize it to that</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;                }</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;                <span class="keywordtype">void</span> generateFixedTrees(HuffmanTree&amp; tree, HuffmanTree&amp; treeD) <span class="comment">//get the tree of a deflated block with fixed tree</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;                {</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;                    std::vector&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>&gt; bitlen(288, 8), bitlenD(32, 5);;</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;                    <span class="keywordflow">for</span> (size_t i = 144; i &lt;= 255; i++) bitlen[i] = 9;</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;                    <span class="keywordflow">for</span> (size_t i = 256; i &lt;= 279; i++) bitlen[i] = 7;</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;                    tree.makeFromLengths(bitlen, 15);</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;                    treeD.makeFromLengths(bitlenD, 15);</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;                }</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;                HuffmanTree codetree, codetreeD, codelengthcodetree; <span class="comment">//the code tree for Huffman codes, dist codes, and code length codes</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;                <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> huffmanDecodeSymbol(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, size_t&amp; bp, <span class="keyword">const</span> HuffmanTree&amp; codetree, size_t inlength)</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;                { <span class="comment">//decode a single symbol from given list of bits with given code tree. return value is the symbol</span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;                    <span class="keywordtype">bool</span> decoded; <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ct;</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;                    <span class="keywordflow">for</span> (size_t treepos = 0;;)</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;                    {</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;                        <span class="keywordflow">if</span> ((bp &amp; 0x07) == 0 &amp;&amp; (bp &gt;&gt; 3) &gt; inlength) { error = 10; <span class="keywordflow">return</span> 0; } <span class="comment">//error: end reached without endcode</span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;                        error = codetree.decode(decoded, ct, treepos, readBitFromStream(bp, in)); <span class="keywordflow">if</span> (error) <span class="keywordflow">return</span> 0; <span class="comment">//stop, an error happened</span></div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;                        <span class="keywordflow">if</span> (decoded) <span class="keywordflow">return</span> ct;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;                    }</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;                }</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;                <span class="keywordtype">void</span> getTreeInflateDynamic(HuffmanTree&amp; tree, HuffmanTree&amp; treeD, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, size_t&amp; bp, size_t inlength)</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;                { <span class="comment">//get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;                    std::vector&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>&gt; bitlen(288, 0), bitlenD(32, 0);</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;                    <span class="keywordflow">if</span> (bp &gt;&gt; 3 &gt;= inlength - 2) { error = 49; <span class="keywordflow">return</span>; } <span class="comment">//the bit pointer is or will go past the memory</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;                    size_t HLIT = readBitsFromStream(bp, in, 5) + 257; <span class="comment">//number of literal/length codes + 257</span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;                    size_t HDIST = readBitsFromStream(bp, in, 5) + 1; <span class="comment">//number of dist codes + 1</span></div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;                    size_t HCLEN = readBitsFromStream(bp, in, 4) + 4; <span class="comment">//number of code length codes + 4</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;                    std::vector&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>&gt; codelengthcode(19); <span class="comment">//lengths of tree to decode the lengths of the dynamic tree</span></div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;                    <span class="keywordflow">for</span> (size_t i = 0; i &lt; 19; i++) codelengthcode[CLCL[i]] = (i &lt; HCLEN) ? readBitsFromStream(bp, in, 3) : 0;</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;                    error = codelengthcodetree.makeFromLengths(codelengthcode, 7); <span class="keywordflow">if</span> (error) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;                    size_t i = 0, replength;</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;                    <span class="keywordflow">while</span> (i &lt; HLIT + HDIST)</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;                    {</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;                        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> code = huffmanDecodeSymbol(in, bp, codelengthcodetree, inlength); <span class="keywordflow">if</span> (error) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;                        <span class="keywordflow">if</span> (code &lt;= 15)  { <span class="keywordflow">if</span> (i &lt; HLIT) bitlen[i++] = code; <span class="keywordflow">else</span> bitlenD[i++ - HLIT] = code; } <span class="comment">//a length code</span></div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;                        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code == 16) <span class="comment">//repeat previous</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;                        {</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                            <span class="keywordflow">if</span> (bp &gt;&gt; 3 &gt;= inlength) { error = 50; <span class="keywordflow">return</span>; } <span class="comment">//error, bit pointer jumps past memory</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                            replength = 3 + readBitsFromStream(bp, in, 2);</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;                            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> value; <span class="comment">//set value to the previous code</span></div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;                            <span class="keywordflow">if</span> ((i - 1) &lt; HLIT) value = bitlen[i - 1];</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;                            <span class="keywordflow">else</span> value = bitlenD[i - HLIT - 1];</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;                            <span class="keywordflow">for</span> (size_t n = 0; n &lt; replength; n++) <span class="comment">//repeat this value in the next lengths</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;                            {</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;                                <span class="keywordflow">if</span> (i &gt;= HLIT + HDIST) { error = 13; <span class="keywordflow">return</span>; } <span class="comment">//error: i is larger than the amount of codes</span></div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;                                <span class="keywordflow">if</span> (i &lt; HLIT) bitlen[i++] = value; <span class="keywordflow">else</span> bitlenD[i++ - HLIT] = value;</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;                            }</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code == 17) <span class="comment">//repeat &quot;0&quot; 3-10 times</span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                        {</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;                            <span class="keywordflow">if</span> (bp &gt;&gt; 3 &gt;= inlength) { error = 50; <span class="keywordflow">return</span>; } <span class="comment">//error, bit pointer jumps past memory</span></div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                            replength = 3 + readBitsFromStream(bp, in, 3);</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                            <span class="keywordflow">for</span> (size_t n = 0; n &lt; replength; n++) <span class="comment">//repeat this value in the next lengths</span></div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;                            {</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;                                <span class="keywordflow">if</span> (i &gt;= HLIT + HDIST) { error = 14; <span class="keywordflow">return</span>; } <span class="comment">//error: i is larger than the amount of codes</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;                                <span class="keywordflow">if</span> (i &lt; HLIT) bitlen[i++] = 0; <span class="keywordflow">else</span> bitlenD[i++ - HLIT] = 0;</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;                            }</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;                        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code == 18) <span class="comment">//repeat &quot;0&quot; 11-138 times</span></div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                        {</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;                            <span class="keywordflow">if</span> (bp &gt;&gt; 3 &gt;= inlength) { error = 50; <span class="keywordflow">return</span>; } <span class="comment">//error, bit pointer jumps past memory</span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;                            replength = 11 + readBitsFromStream(bp, in, 7);</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;                            <span class="keywordflow">for</span> (size_t n = 0; n &lt; replength; n++) <span class="comment">//repeat this value in the next lengths</span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;                            {</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;                                <span class="keywordflow">if</span> (i &gt;= HLIT + HDIST) { error = 15; <span class="keywordflow">return</span>; } <span class="comment">//error: i is larger than the amount of codes</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;                                <span class="keywordflow">if</span> (i &lt; HLIT) bitlen[i++] = 0; <span class="keywordflow">else</span> bitlenD[i++ - HLIT] = 0;</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;                            }</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;                        } <span class="keywordflow">else</span> { error = 16; <span class="keywordflow">return</span>; } <span class="comment">//error: somehow an unexisting code appeared. This can never happen.</span></div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;                    }</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;                    <span class="keywordflow">if</span> (bitlen[256] == 0) { error = 64; <span class="keywordflow">return</span>; } <span class="comment">//the length of the end code 256 must be larger than 0</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;                    error = tree.makeFromLengths(bitlen, 15); <span class="keywordflow">if</span> (error) <span class="keywordflow">return</span>; <span class="comment">//now we&#39;ve finally got HLIT and HDIST, so generate the code trees, and the function is done</span></div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;                    error = treeD.makeFromLengths(bitlenD, 15); <span class="keywordflow">if</span> (error) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;                }</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                <span class="keywordtype">void</span> inflateHuffmanBlock(std::vector&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;&amp; out, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, size_t&amp; bp, size_t&amp; pos, size_t inlength, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> btype)</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;                {</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;                    <span class="keywordflow">if</span> (btype == 1) { generateFixedTrees(codetree, codetreeD); } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (btype == 2) { getTreeInflateDynamic(codetree, codetreeD, in, bp, inlength); <span class="keywordflow">if</span> (error) <span class="keywordflow">return</span>; }</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;                    <span class="keywordflow">for</span> (;;)</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;                    {</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;                        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> code = huffmanDecodeSymbol(in, bp, codetree, inlength); <span class="keywordflow">if</span> (error) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;                        <span class="keywordflow">if</span> (code == 256) <span class="keywordflow">return</span>; <span class="comment">//end code</span></div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;                        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code &lt;= 255) <span class="comment">//literal symbol</span></div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;                        {</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;                            <span class="keywordflow">if</span> (pos &gt;= out.size()) out.resize((pos + 1) * 2); <span class="comment">//reserve more room</span></div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;                            out[pos++] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(code);</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;                        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code &gt;= 257 &amp;&amp; code &lt;= 285) <span class="comment">//length code</span></div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;                        {</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;                            size_t length = LENBASE[code - 257], numextrabits = LENEXTRA[code - 257];</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;                            <span class="keywordflow">if</span> ((bp &gt;&gt; 3) &gt;= inlength) { error = 51; <span class="keywordflow">return</span>; } <span class="comment">//error, bit pointer will jump past memory</span></div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;                            length += readBitsFromStream(bp, in, numextrabits);</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;                            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> codeD = huffmanDecodeSymbol(in, bp, codetreeD, inlength); <span class="keywordflow">if</span> (error) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;                            <span class="keywordflow">if</span> (codeD &gt; 29) { error = 18; <span class="keywordflow">return</span>; } <span class="comment">//error: invalid dist code (30-31 are never used)</span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;                            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dist = DISTBASE[codeD], numextrabitsD = DISTEXTRA[codeD];</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;                            <span class="keywordflow">if</span> ((bp &gt;&gt; 3) &gt;= inlength) { error = 51; <span class="keywordflow">return</span>; } <span class="comment">//error, bit pointer will jump past memory</span></div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;                            dist += readBitsFromStream(bp, in, numextrabitsD);</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;                            size_t start = pos, back = start - dist; <span class="comment">//backwards</span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                            <span class="keywordflow">if</span> (pos + length &gt;= out.size()) out.resize((pos + length) * 2); <span class="comment">//reserve more room</span></div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;                            <span class="keywordflow">for</span> (size_t i = 0; i &lt; length; i++) { out[pos++] = out[back++]; <span class="keywordflow">if</span> (back &gt;= start) back = start - dist; }</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;                        }</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;                    }</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;                }</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                <span class="keywordtype">void</span> inflateNoCompression(std::vector&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;&amp; out, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, size_t&amp; bp, size_t&amp; pos, size_t inlength)</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                {</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                    <span class="keywordflow">while</span> ((bp &amp; 0x7) != 0) bp++; <span class="comment">//go to first boundary of byte</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                    size_t p = bp / 8;</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;                    <span class="keywordflow">if</span> (p &gt;= inlength - 4) { error = 52; <span class="keywordflow">return</span>; } <span class="comment">//error, bit pointer will jump past memory</span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> LEN = in[p] + 256 * in[p + 1], NLEN = in[p + 2] + 256 * in[p + 3]; p += 4;</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;                    <span class="keywordflow">if</span> (LEN + NLEN != 65535) { error = 21; <span class="keywordflow">return</span>; } <span class="comment">//error: NLEN is not one&#39;s complement of LEN</span></div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;                    <span class="keywordflow">if</span> (pos + LEN &gt;= out.size()) out.resize(pos + LEN);</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                    <span class="keywordflow">if</span> (p + LEN &gt; inlength) { error = 23; <span class="keywordflow">return</span>; } <span class="comment">//error: reading outside of in buffer</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> n = 0; n &lt; LEN; n++) out[pos++] = in[p++]; <span class="comment">//read LEN bytes of literal data</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;                    bp = p * 8;</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;                }</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;            };</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;            <span class="keywordtype">int</span> decompress(std::vector&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;&amp; out, <span class="keyword">const</span> std::vector&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;&amp; in) <span class="comment">//returns error value</span></div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;            {</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;                Inflator inflator;</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;                <span class="keywordflow">if</span> (in.size() &lt; 2) { <span class="keywordflow">return</span> 53; } <span class="comment">//error, size of zlib data too small</span></div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;                <span class="keywordflow">if</span> ((in[0] * 256 + in[1]) % 31 != 0) { <span class="keywordflow">return</span> 24; } <span class="comment">//error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;                <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> CM = in[0] &amp; 15, CINFO = (in[0] &gt;&gt; 4) &amp; 15, FDICT = (in[1] &gt;&gt; 5) &amp; 1;</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                <span class="keywordflow">if</span> (CM != 8 || CINFO &gt; 7) { <span class="keywordflow">return</span> 25; } <span class="comment">//error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec</span></div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;                <span class="keywordflow">if</span> (FDICT != 0) { <span class="keywordflow">return</span> 26; } <span class="comment">//error: the specification of PNG says about the zlib stream: &quot;The additional flags shall not specify a preset dictionary.&quot;</span></div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;                inflator.inflate(out, in, 2);</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;                <span class="keywordflow">return</span> inflator.error; <span class="comment">//note: adler32 checksum was skipped and ignored</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;            }</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;        };</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;        <span class="keyword">struct</span> PNG <span class="comment">//nested functions for PNG decoding</span></div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        {</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;            <span class="keyword">struct</span> Info</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;            {</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;                <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> width, height, colorType, bitDepth, compressionMethod, filterMethod, interlaceMethod, key_r, key_g, key_b;</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;                <span class="keywordtype">bool</span> key_defined; <span class="comment">//is a transparent color key given?</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;                std::vector&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt; palette;</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;            } info;</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;            <span class="keywordtype">int</span> error;</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;            <span class="keywordtype">void</span> decode(std::vector&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;&amp; out, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, size_t size, <span class="keywordtype">bool</span> convert_to_rgba32)</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;            {</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;                error = 0;</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;                <span class="keywordflow">if</span> (size == 0 || in == 0) { error = 48; <span class="keywordflow">return</span>; } <span class="comment">//the given data is empty</span></div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;                readPngHeader(&amp;in[0], size); <span class="keywordflow">if</span> (error) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;                size_t pos = 33; <span class="comment">//first byte of the first chunk after the header</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;                std::vector&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt; idat; <span class="comment">//the data from idat chunks</span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;                <span class="keywordtype">bool</span> IEND = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;                info.key_defined = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;                <span class="keywordflow">while</span> (!IEND) <span class="comment">//loop through the chunks, ignoring unknown chunks and stopping at IEND chunk. IDAT data is put at the start of the in buffer</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;                {</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;                    <span class="keywordflow">if</span> (pos + 8 &gt;= size) { error = 30; <span class="keywordflow">return</span>; } <span class="comment">//error: size of the in buffer too small to contain next chunk</span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                    size_t chunkLength = read32bitInt(&amp;in[pos]); pos += 4;</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;                    <span class="keywordflow">if</span> (chunkLength &gt; 2147483647) { error = 63; <span class="keywordflow">return</span>; }</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;                    <span class="keywordflow">if</span> (pos + chunkLength &gt;= size) { error = 35; <span class="keywordflow">return</span>; } <span class="comment">//error: size of the in buffer too small to contain next chunk</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;                    <span class="keywordflow">if</span> (in[pos + 0] == <span class="stringliteral">&#39;I&#39;</span> &amp;&amp; in[pos + 1] == <span class="stringliteral">&#39;D&#39;</span> &amp;&amp; in[pos + 2] == <span class="stringliteral">&#39;A&#39;</span> &amp;&amp; in[pos + 3] == <span class="stringliteral">&#39;T&#39;</span>) <span class="comment">//IDAT chunk, containing compressed image data</span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;                    {</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;                        idat.insert(idat.end(), &amp;in[pos + 4], &amp;in[pos + 4 + chunkLength]);</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;                        pos += (4 + chunkLength);</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (in[pos + 0] == <span class="stringliteral">&#39;I&#39;</span> &amp;&amp; in[pos + 1] == <span class="stringliteral">&#39;E&#39;</span> &amp;&amp; in[pos + 2] == <span class="stringliteral">&#39;N&#39;</span> &amp;&amp; in[pos + 3] == <span class="stringliteral">&#39;D&#39;</span>)  { pos += 4; IEND = <span class="keyword">true</span>; } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (in[pos + 0] == <span class="stringliteral">&#39;P&#39;</span> &amp;&amp; in[pos + 1] == <span class="stringliteral">&#39;L&#39;</span> &amp;&amp; in[pos + 2] == <span class="stringliteral">&#39;T&#39;</span> &amp;&amp; in[pos + 3] == <span class="stringliteral">&#39;E&#39;</span>) <span class="comment">//palette chunk (PLTE)</span></div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;                    {</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                        pos += 4; <span class="comment">//go after the 4 letters</span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;                        info.palette.resize(4 * (chunkLength / 3));</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                        <span class="keywordflow">if</span> (info.palette.size() &gt; (4 * 256)) { error = 38; <span class="keywordflow">return</span>; } <span class="comment">//error: palette too big</span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;                        <span class="keywordflow">for</span> (size_t i = 0; i &lt; info.palette.size(); i += 4)</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;                        {</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;                            <span class="keywordflow">for</span> (size_t j = 0; j &lt; 3; j++) info.palette[i + j] = in[pos++]; <span class="comment">//RGB</span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;                            info.palette[i + 3] = 255; <span class="comment">//alpha</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;                        }</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (in[pos + 0] == <span class="stringliteral">&#39;t&#39;</span> &amp;&amp; in[pos + 1] == <span class="stringliteral">&#39;R&#39;</span> &amp;&amp; in[pos + 2] == <span class="stringliteral">&#39;N&#39;</span> &amp;&amp; in[pos + 3] == <span class="stringliteral">&#39;S&#39;</span>) <span class="comment">//palette transparency chunk (tRNS)</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;                    {</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;                        pos += 4; <span class="comment">//go after the 4 letters</span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;                        <span class="keywordflow">if</span> (info.colorType == 3)</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;                        {</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;                            <span class="keywordflow">if</span> (4 * chunkLength &gt; info.palette.size()) { error = 39; <span class="keywordflow">return</span>; } <span class="comment">//error: more alpha values given than there are palette entries</span></div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;                            <span class="keywordflow">for</span> (size_t i = 0; i &lt; chunkLength; i++) info.palette[4 * i + 3] = in[pos++];</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;                        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (info.colorType == 0)</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;                        {</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;                            <span class="keywordflow">if</span> (chunkLength != 2) { error = 40; <span class="keywordflow">return</span>; } <span class="comment">//error: this chunk must be 2 bytes for greyscale image</span></div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;                            info.key_defined = 1; info.key_r = info.key_g = info.key_b = 256 * in[pos] + in[pos + 1]; pos += 2;</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;                        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (info.colorType == 2)</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;                        {</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;                            <span class="keywordflow">if</span> (chunkLength != 6) { error = 41; <span class="keywordflow">return</span>; } <span class="comment">//error: this chunk must be 6 bytes for RGB image</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;                            info.key_defined = 1;</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;                            info.key_r = 256 * in[pos] + in[pos + 1]; pos += 2;</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;                            info.key_g = 256 * in[pos] + in[pos + 1]; pos += 2;</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;                            info.key_b = 256 * in[pos] + in[pos + 1]; pos += 2;</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;                        } <span class="keywordflow">else</span> { error = 42; <span class="keywordflow">return</span>; } <span class="comment">//error: tRNS chunk not allowed for other color models</span></div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;                    } <span class="keywordflow">else</span> <span class="comment">//it&#39;s not an implemented chunk type, so ignore it: skip over the data</span></div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;                    {</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;                        <span class="keywordflow">if</span> (!(in[pos + 0] &amp; 32)) { error = 69; <span class="keywordflow">return</span>; } <span class="comment">//error: unknown critical chunk (5th bit of first byte of chunk type is 0)</span></div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;                        pos += (chunkLength + 4); <span class="comment">//skip 4 letters and uninterpreted data of unimplemented chunk</span></div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;                    }</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;                    pos += 4; <span class="comment">//step over CRC (which is ignored)</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;                }</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bpp = getBpp(info);</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;                std::vector&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt; scanlines(((info.width * (info.height * bpp + 7)) / 8) + info.height); <span class="comment">//now the out buffer will be filled</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                Zlib zlib; <span class="comment">//decompress with the Zlib decompressor</span></div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;                error = zlib.decompress(scanlines, idat); <span class="keywordflow">if</span> (error) <span class="keywordflow">return</span>; <span class="comment">//stop if the zlib decompressor returned an error</span></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;                size_t bytewidth = (bpp + 7) / 8, outlength = (info.height * info.width * bpp + 7) / 8;</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;                out.resize(outlength); <span class="comment">//time to fill the out buffer</span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* out_ = outlength ? &amp;out[0] : 0; <span class="comment">//use a regular pointer to the std::vector for faster code if compiled without optimization</span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;                <span class="keywordflow">if</span> (info.interlaceMethod == 0) <span class="comment">//no interlace, just filter</span></div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;                {</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;                    size_t linestart = 0, linelength = (info.width * bpp + 7) / 8; <span class="comment">//length in bytes of a scanline, excluding the filtertype byte</span></div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;                    <span class="keywordflow">if</span> (bpp &gt;= 8) <span class="comment">//byte per byte</span></div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> y = 0; y &lt; info.height; y++)</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;                    {</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;                        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> filterType = scanlines[linestart];</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* prevline = (y == 0) ? 0 : &amp;out_[(y - 1) * info.width * bytewidth];</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;                        unFilterScanline(&amp;out_[linestart - y], &amp;scanlines[linestart + 1], prevline, bytewidth, filterType, linelength); <span class="keywordflow">if</span> (error) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;                        linestart += (1 + linelength); <span class="comment">//go to start of next scanline</span></div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;                    } <span class="keywordflow">else</span> <span class="comment">//less than 8 bits per pixel, so fill it up bit per bit</span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;                    {</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;                        std::vector&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt; templine((info.width * bpp + 7) &gt;&gt; 3); <span class="comment">//only used if bpp &lt; 8</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;                        <span class="keywordflow">for</span> (size_t y = 0, obp = 0; y &lt; info.height; y++)</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;                        {</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;                            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> filterType = scanlines[linestart];</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* prevline = (y == 0) ? 0 : &amp;out_[(y - 1) * info.width * bytewidth];</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;                            unFilterScanline(&amp;templine[0], &amp;scanlines[linestart + 1], prevline, bytewidth, filterType, linelength); <span class="keywordflow">if</span> (error) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;                            <span class="keywordflow">for</span> (size_t bp = 0; bp &lt; info.width * bpp;) setBitOfReversedStream(obp, out_, readBitFromReversedStream(bp, &amp;templine[0]));</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                            linestart += (1 + linelength); <span class="comment">//go to start of next scanline</span></div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;                        }</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                    }</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;                } <span class="keywordflow">else</span> <span class="comment">//interlaceMethod is 1 (Adam7)</span></div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;                {</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;                    size_t passw[7] = { (info.width + 7) / 8, (info.width + 3) / 8, (info.width + 3) / 4, (info.width + 1) / 4, (info.width + 1) / 2, (info.width + 0) / 2, (info.width + 0) / 1 };</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;                    size_t passh[7] = { (info.height + 7) / 8, (info.height + 7) / 8, (info.height + 3) / 8, (info.height + 3) / 4, (info.height + 1) / 4, (info.height + 1) / 2, (info.height + 0) / 2 };</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;                    size_t passstart[7] = { 0 };</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;                    size_t pattern[28] = { 0, 4, 0, 2, 0, 1, 0, 0, 0, 4, 0, 2, 0, 1, 8, 8, 4, 4, 2, 2, 1, 8, 8, 8, 4, 4, 2, 2 }; <span class="comment">//values for the adam7 passes</span></div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 6; i++) passstart[i + 1] = passstart[i] + passh[i] * ((passw[i] ? 1 : 0) + (passw[i] * bpp + 7) / 8);</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;                    std::vector&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt; scanlineo((info.width * bpp + 7) / 8), scanlinen((info.width * bpp + 7) / 8); <span class="comment">//&quot;old&quot; and &quot;new&quot; scanline</span></div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 7; i++)</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;                        adam7Pass(&amp;out_[0], &amp;scanlinen[0], &amp;scanlineo[0], &amp;scanlines[passstart[i]], info.width, pattern[i], pattern[i + 7], pattern[i + 14], pattern[i + 21], passw[i], passh[i], bpp);</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;                }</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;                <span class="keywordflow">if</span> (convert_to_rgba32 &amp;&amp; (info.colorType != 6 || info.bitDepth != 8)) <span class="comment">//conversion needed</span></div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;                {</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;                    std::vector&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt; data = out;</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;                    error = convert(out, &amp;data[0], info, info.width, info.height);</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;                }</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;            }</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;            <span class="keywordtype">void</span> readPngHeader(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, size_t inlength) <span class="comment">//read the information from the header and store it in the Info</span></div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;            {</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;                <span class="keywordflow">if</span> (inlength &lt; 29) { error = 27; <span class="keywordflow">return</span>; } <span class="comment">//error: the data length is smaller than the length of the header</span></div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;                <span class="keywordflow">if</span> (in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71 || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) { error = 28; <span class="keywordflow">return</span>; } <span class="comment">//no PNG signature</span></div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;                <span class="keywordflow">if</span> (in[12] != <span class="stringliteral">&#39;I&#39;</span> || in[13] != <span class="stringliteral">&#39;H&#39;</span> || in[14] != <span class="stringliteral">&#39;D&#39;</span> || in[15] != <span class="stringliteral">&#39;R&#39;</span>) { error = 29; <span class="keywordflow">return</span>; } <span class="comment">//error: it doesn&#39;t start with a IHDR chunk!</span></div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;                info.width = read32bitInt(&amp;in[16]); info.height = read32bitInt(&amp;in[20]);</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;                info.bitDepth = in[24]; info.colorType = in[25];</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;                info.compressionMethod = in[26]; <span class="keywordflow">if</span> (in[26] != 0) { error = 32; <span class="keywordflow">return</span>; } <span class="comment">//error: only compression method 0 is allowed in the specification</span></div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;                info.filterMethod = in[27]; <span class="keywordflow">if</span> (in[27] != 0) { error = 33; <span class="keywordflow">return</span>; } <span class="comment">//error: only filter method 0 is allowed in the specification</span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;                info.interlaceMethod = in[28]; <span class="keywordflow">if</span> (in[28] &gt; 1) { error = 34; <span class="keywordflow">return</span>; } <span class="comment">//error: only interlace methods 0 and 1 exist in the specification</span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;                error = checkColorValidity(info.colorType, info.bitDepth);</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;            }</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;            <span class="keywordtype">void</span> unFilterScanline(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* recon, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* scanline, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* precon, size_t bytewidth, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> filterType, size_t length)</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;            {</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;                <span class="keywordflow">switch</span> (filterType)</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;                {</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;                    <span class="keywordflow">case</span> 0: <span class="keywordflow">for</span> (size_t i = 0; i &lt; length; i++) recon[i] = scanline[i]; <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;                    <span class="keywordflow">case</span> 1:</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;                        <span class="keywordflow">for</span> (size_t i = 0; i &lt; bytewidth; i++) recon[i] = scanline[i];</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;                        <span class="keywordflow">for</span> (size_t i = bytewidth; i &lt; length; i++) recon[i] = scanline[i] + recon[i - bytewidth];</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;                    <span class="keywordflow">case</span> 2:</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;                        <span class="keywordflow">if</span> (precon) <span class="keywordflow">for</span> (size_t i = 0; i &lt; length; i++) recon[i] = scanline[i] + precon[i];</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;                        <span class="keywordflow">else</span>       <span class="keywordflow">for</span> (size_t i = 0; i &lt; length; i++) recon[i] = scanline[i];</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;                    <span class="keywordflow">case</span> 3:</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;                        <span class="keywordflow">if</span> (precon)</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;                        {</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;                            <span class="keywordflow">for</span> (size_t i = 0; i &lt; bytewidth; i++) recon[i] = scanline[i] + precon[i] / 2;</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;                            <span class="keywordflow">for</span> (size_t i = bytewidth; i &lt; length; i++) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) / 2);</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;                        } <span class="keywordflow">else</span></div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;                        {</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;                            <span class="keywordflow">for</span> (size_t i = 0; i &lt; bytewidth; i++) recon[i] = scanline[i];</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;                            <span class="keywordflow">for</span> (size_t i = bytewidth; i &lt; length; i++) recon[i] = scanline[i] + recon[i - bytewidth] / 2;</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;                        }</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;                    <span class="keywordflow">case</span> 4:</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;                        <span class="keywordflow">if</span> (precon)</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;                        {</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;                            <span class="keywordflow">for</span> (size_t i = 0; i &lt; bytewidth; i++) recon[i] = scanline[i] + paethPredictor(0, precon[i], 0);</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;                            <span class="keywordflow">for</span> (size_t i = bytewidth; i &lt; length; i++) recon[i] = scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]);</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;                        } <span class="keywordflow">else</span></div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;                        {</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;                            <span class="keywordflow">for</span> (size_t i = 0; i &lt; bytewidth; i++) recon[i] = scanline[i];</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;                            <span class="keywordflow">for</span> (size_t i = bytewidth; i &lt; length; i++) recon[i] = scanline[i] + paethPredictor(recon[i - bytewidth], 0, 0);</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;                        }</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;                    <span class="keywordflow">default</span>: error = 36; <span class="keywordflow">return</span>; <span class="comment">//error: unexisting filter type given</span></div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;                }</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;            }</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;            <span class="keywordtype">void</span> adam7Pass(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* out, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* linen, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* lineo, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> w, size_t passleft, size_t passtop, size_t spacex, size_t spacey, size_t passw, size_t passh, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bpp)</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;            { <span class="comment">//filter and reposition the pixels into the output when the image is Adam7 interlaced. This function can only do it after the full image is already decoded. The out buffer must have the correct allocated memory size already.</span></div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;                <span class="keywordflow">if</span> (passw == 0) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;                size_t bytewidth = (bpp + 7) / 8, linelength = 1 + ((bpp * passw + 7) / 8);</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> y = 0; y &lt; passh; y++)</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;                {</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;                    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> filterType = in[y * linelength], *prevline = (y == 0) ? 0 : lineo;</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;                    unFilterScanline(linen, &amp;in[y * linelength + 1], prevline, bytewidth, filterType, (w * bpp + 7) / 8); <span class="keywordflow">if</span> (error) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;                    <span class="keywordflow">if</span> (bpp &gt;= 8) <span class="keywordflow">for</span> (size_t i = 0; i &lt; passw; i++) <span class="keywordflow">for</span> (size_t b = 0; b &lt; bytewidth; b++) <span class="comment">//b = current byte of this pixel</span></div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;                        out[bytewidth * w * (passtop + spacey * y) + bytewidth * (passleft + spacex * i) + b] = linen[bytewidth * i + b];</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;                    <span class="keywordflow">else</span> <span class="keywordflow">for</span> (size_t i = 0; i &lt; passw; i++)</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;                    {</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;                        size_t obp = bpp * w * (passtop + spacey * y) + bpp * (passleft + spacex * i), bp = i * bpp;</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;                        <span class="keywordflow">for</span> (size_t b = 0; b &lt; bpp; b++) setBitOfReversedStream(obp, out, readBitFromReversedStream(bp, &amp;linen[0]));</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;                    }</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;                    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* temp = linen; linen = lineo; lineo = temp; <span class="comment">//swap the two buffer pointers &quot;line old&quot; and &quot;line new&quot;</span></div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;                }</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;            }</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;            <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> readBitFromReversedStream(size_t&amp; bitp, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* bits) { <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> result = (bits[bitp &gt;&gt; 3] &gt;&gt; (7 - (bitp &amp; 0x7))) &amp; 1; bitp++; <span class="keywordflow">return</span> result; }</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;            <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> readBitsFromReversedStream(size_t&amp; bitp, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* bits, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nbits)</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;            {</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;                <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> result = 0;</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;                <span class="keywordflow">for</span> (size_t i = nbits - 1; i &lt; nbits; i--) result += ((readBitFromReversedStream(bitp, bits)) &lt;&lt; i);</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;            }</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;            <span class="keywordtype">void</span> setBitOfReversedStream(size_t&amp; bitp, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* bits, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bit) { bits[bitp &gt;&gt; 3] |= (bit &lt;&lt; (7 - (bitp &amp; 0x7))); bitp++; }</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> read32bitInt(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buffer) { <span class="keywordflow">return</span> (buffer[0] &lt;&lt; 24) | (buffer[1] &lt;&lt; 16) | (buffer[2] &lt;&lt; 8) | buffer[3]; }</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;            <span class="keywordtype">int</span> checkColorValidity(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> colorType, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bd) <span class="comment">//return type is a LodePNG error code</span></div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;            {</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;                <span class="keywordflow">if</span> ((colorType == 2 || colorType == 4 || colorType == 6)) { <span class="keywordflow">if</span> (!(bd == 8 || bd == 16)) <span class="keywordflow">return</span> 37; <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0; } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (colorType == 0) { <span class="keywordflow">if</span> (!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) <span class="keywordflow">return</span> 37; <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0; } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (colorType == 3) { <span class="keywordflow">if</span> (!(bd == 1 || bd == 2 || bd == 4 || bd == 8)) <span class="keywordflow">return</span> 37; <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0; } <span class="keywordflow">else</span> <span class="keywordflow">return</span> 31; <span class="comment">//unexisting color type</span></div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;            }</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> getBpp(<span class="keyword">const</span> Info&amp; info)</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;            {</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;                <span class="keywordflow">if</span> (info.colorType == 2) <span class="keywordflow">return</span> (3 * info.bitDepth);</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (info.colorType &gt;= 4) <span class="keywordflow">return</span> (info.colorType - 2) * info.bitDepth;</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">return</span> info.bitDepth;</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;            }</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;            <span class="keywordtype">int</span> convert(std::vector&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;&amp; out, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, Info&amp; infoIn, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> w, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> h)</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;            { <span class="comment">//converts from any color type to 32-bit. return value = LodePNG error code</span></div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;                size_t numpixels = w * h, bp = 0;</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;                out.resize(numpixels * 4);</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* out_ = out.empty() ? 0 : &amp;out[0]; <span class="comment">//faster if compiled without optimization</span></div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;                <span class="keywordflow">if</span> (infoIn.bitDepth == 8 &amp;&amp; infoIn.colorType == 0) <span class="comment">//greyscale</span></div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;                <span class="keywordflow">for</span> (size_t i = 0; i &lt; numpixels; i++)</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;                {</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;                    out_[4 * i + 0] = out_[4 * i + 1] = out_[4 * i + 2] = in[i];</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;                    out_[4 * i + 3] = (infoIn.key_defined &amp;&amp; in[i] == infoIn.key_r) ? 0 : 255;</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (infoIn.bitDepth == 8 &amp;&amp; infoIn.colorType == 2) <span class="comment">//RGB color</span></div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;                <span class="keywordflow">for</span> (size_t i = 0; i &lt; numpixels; i++)</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;                {</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;                    <span class="keywordflow">for</span> (size_t c = 0; c &lt; 3; c++) out_[4 * i + c] = in[3 * i + c];</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;                    out_[4 * i + 3] = (infoIn.key_defined == 1 &amp;&amp; in[3 * i + 0] == infoIn.key_r &amp;&amp; in[3 * i + 1] == infoIn.key_g &amp;&amp; in[3 * i + 2] == infoIn.key_b) ? 0 : 255;</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (infoIn.bitDepth == 8 &amp;&amp; infoIn.colorType == 3) <span class="comment">//indexed color (palette)</span></div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;                <span class="keywordflow">for</span> (size_t i = 0; i &lt; numpixels; i++)</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;                {</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;                    <span class="keywordflow">if</span> (4U * in[i] &gt;= infoIn.palette.size()) <span class="keywordflow">return</span> 46;</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;                    <span class="keywordflow">for</span> (size_t c = 0; c &lt; 4; c++) out_[4 * i + c] = infoIn.palette[4 * in[i] + c]; <span class="comment">//get rgb colors from the palette</span></div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (infoIn.bitDepth == 8 &amp;&amp; infoIn.colorType == 4) <span class="comment">//greyscale with alpha</span></div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;                <span class="keywordflow">for</span> (size_t i = 0; i &lt; numpixels; i++)</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;                {</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;                    out_[4 * i + 0] = out_[4 * i + 1] = out_[4 * i + 2] = in[2 * i + 0];</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;                    out_[4 * i + 3] = in[2 * i + 1];</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (infoIn.bitDepth == 8 &amp;&amp; infoIn.colorType == 6) <span class="keywordflow">for</span> (size_t i = 0; i &lt; numpixels; i++) <span class="keywordflow">for</span> (size_t c = 0; c &lt; 4; c++) out_[4 * i + c] = in[4 * i + c]; <span class="comment">//RGB with alpha</span></div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (infoIn.bitDepth == 16 &amp;&amp; infoIn.colorType == 0) <span class="comment">//greyscale</span></div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;                <span class="keywordflow">for</span> (size_t i = 0; i &lt; numpixels; i++)</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;                {</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;                    out_[4 * i + 0] = out_[4 * i + 1] = out_[4 * i + 2] = in[2 * i];</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;                    out_[4 * i + 3] = (infoIn.key_defined &amp;&amp; 256U * in[i] + in[i + 1] == infoIn.key_r) ? 0 : 255;</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (infoIn.bitDepth == 16 &amp;&amp; infoIn.colorType == 2) <span class="comment">//RGB color</span></div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;                <span class="keywordflow">for</span> (size_t i = 0; i &lt; numpixels; i++)</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;                {</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;                    <span class="keywordflow">for</span> (size_t c = 0; c &lt; 3; c++) out_[4 * i + c] = in[6 * i + 2 * c];</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;                    out_[4 * i + 3] = (infoIn.key_defined &amp;&amp; 256U * in[6 * i + 0] + in[6 * i + 1] == infoIn.key_r &amp;&amp; 256U * in[6 * i + 2] + in[6 * i + 3] == infoIn.key_g &amp;&amp; 256U * in[6 * i + 4] + in[6 * i + 5] == infoIn.key_b) ? 0 : 255;</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (infoIn.bitDepth == 16 &amp;&amp; infoIn.colorType == 4) <span class="comment">//greyscale with alpha</span></div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;                <span class="keywordflow">for</span> (size_t i = 0; i &lt; numpixels; i++)</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;                {</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;                    out_[4 * i + 0] = out_[4 * i + 1] = out_[4 * i + 2] = in[4 * i]; <span class="comment">//most significant byte</span></div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;                    out_[4 * i + 3] = in[4 * i + 2];</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (infoIn.bitDepth == 16 &amp;&amp; infoIn.colorType == 6) <span class="keywordflow">for</span> (size_t i = 0; i &lt; numpixels; i++) <span class="keywordflow">for</span> (size_t c = 0; c &lt; 4; c++) out_[4 * i + c] = in[8 * i + 2 * c]; <span class="comment">//RGB with alpha</span></div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (infoIn.bitDepth &lt; 8 &amp;&amp; infoIn.colorType == 0) <span class="comment">//greyscale</span></div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;                <span class="keywordflow">for</span> (size_t i = 0; i &lt; numpixels; i++)</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;                {</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;                    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> value = (readBitsFromReversedStream(bp, in, infoIn.bitDepth) * 255) / ((1 &lt;&lt; infoIn.bitDepth) - 1); <span class="comment">//scale value from 0 to 255</span></div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;                    out_[4 * i + 0] = out_[4 * i + 1] = out_[4 * i + 2] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(value);</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;                    out_[4 * i + 3] = (infoIn.key_defined &amp;&amp; value &amp;&amp; ((1U &lt;&lt; infoIn.bitDepth) - 1U) == infoIn.key_r &amp;&amp; ((1U &lt;&lt; infoIn.bitDepth) - 1U)) ? 0 : 255;</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (infoIn.bitDepth &lt; 8 &amp;&amp; infoIn.colorType == 3) <span class="comment">//palette</span></div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;                <span class="keywordflow">for</span> (size_t i = 0; i &lt; numpixels; i++)</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;                {</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;                    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> value = readBitsFromReversedStream(bp, in, infoIn.bitDepth);</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;                    <span class="keywordflow">if</span> (4 * value &gt;= infoIn.palette.size()) <span class="keywordflow">return</span> 47;</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;                    <span class="keywordflow">for</span> (size_t c = 0; c &lt; 4; c++) out_[4 * i + c] = infoIn.palette[4 * value + c]; <span class="comment">//get rgb colors from the palette</span></div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;                }</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;                <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;            }</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> paethPredictor(<span class="keywordtype">short</span> a, <span class="keywordtype">short</span> b, <span class="keywordtype">short</span> c) <span class="comment">//Paeth predicter, used by PNG filter type 4</span></div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;            {</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;                <span class="keywordtype">short</span> p = a + b - c, pa = p &gt; a ? (p - a) : (a - p), pb = p &gt; b ? (p - b) : (b - p), pc = p &gt; c ? (p - c) : (c - p);</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;                <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)((pa &lt;= pb &amp;&amp; pa &lt;= pc) ? a : pb &lt;= pc ? b : c);</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;            }</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;        };</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;        PNG decoder; decoder.decode(out_image, in_png, in_size, convert_to_rgba32);</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;        image_width = decoder.info.width; image_height = decoder.info.height;</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;        <span class="keywordflow">return</span> decoder.error;</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;    }</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160; </div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;}</div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="anamespace_b_a_r_e2_d_html"><div class="ttname"><a href="namespace_b_a_r_e2_d.html">BARE2D</a></div><div class="ttdef"><b>Definition:</b> <a href="_app_8cpp_source.html#l00013">App.cpp:13</a></div></div>
<div class="ttc" id="anamespace_b_a_r_e2_d_html_a480b5f334854e31c2d7e026933129480"><div class="ttname"><a href="namespace_b_a_r_e2_d.html#a480b5f334854e31c2d7e026933129480">BARE2D::decodePNG</a></div><div class="ttdeci">int decodePNG(std::vector&lt; unsigned char &gt; &amp;out_image, unsigned long &amp;image_width, unsigned long &amp;image_height, const unsigned char *in_png, std::size_t in_size, bool convert_to_rgba32)</div><div class="ttdef"><b>Definition:</b> <a href="_pico_p_n_g_8cpp_source.html#l00028">PicoPNG.cpp:28</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_8ce3a8ee21fa8a209d228fabb47a61a6.html">Other_Libraries</a></li><li class="navelem"><a class="el" href="_pico_p_n_g_8cpp.html">PicoPNG.cpp</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
